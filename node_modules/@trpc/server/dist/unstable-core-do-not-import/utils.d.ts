type KeyFromValue<TValue, TType extends Record<PropertyKey, PropertyKey>> = {
    [K in keyof TType]: TValue extends TType[K] ? K : never;
}[keyof TType];
type Invert<TType extends Record<PropertyKey, PropertyKey>> = {
    [TValue in TType[keyof TType]]: KeyFromValue<TValue, TType>;
};
/**
 * @internal
 */
export declare function invert<TRecord extends Record<PropertyKey, PropertyKey>>(obj: TRecord): Invert<TRecord>;
/**
 * Ensures there are no duplicate keys when building a procedure.
 * @internal
 */
export declare function mergeWithoutOverrides<TType extends Record<string, unknown>>(obj1: TType, ...objs: Partial<TType>[]): TType;
/**
 * Check that value is object
 * @internal
 */
export declare function isObject(value: unknown): value is Record<string, unknown>;
/**
 * Create an object without inheriting anything from `Object.prototype`
 * @internal
 */
export declare function omitPrototype<TObj extends Record<string, unknown>>(obj: TObj): TObj;
export {};
//# sourceMappingURL=utils.d.ts.map